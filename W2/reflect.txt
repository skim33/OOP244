Woohyuk Kim
Student #: 121968176
Date: 02/02/2018

Reflection:
1
Since arrays are stored in consecutive memory, it is possible that the memory right after the array is allocated for other things. This is why we cannot simply add new cells to the array in order to increase the size of an existing array.

2
As the name of the kingdom in an array is stored in the Kingdom structure, we do not need to deallocate the memory occupied by the name because it happens automatically when kingdom (object), goes out of scope.

3
Two one definition of display() for each set of parameters is generated by the compiler. Based on the argument types in the function call, the linker connects the function call to the appropriate definition.

4
There are two things I was able to understand through this workshop. The first one is how to allocate and deallocate dynamic memory. I learned this mainly from dealing with an array of elements in a structure. The second thing I learned is how to increase the amount of dynamically allocated memory. It took a lot of time for me to figure out how to resize the size of an array and the amount of dynamically allocated memory at the same time.

Quiz 1 Reflection:

Q2: true
Q3: The order of the function's parameters
Q4: void discount(Item &object){}
    discount(apple);
Q5: float *ptr[6];
Q6: double *xxx = new double[n];
Q8: struct Item;